<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
</head><body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">dynamic-graph Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="intro_dynamicGraph"></a>
Introduction</h1>
<p>The dynamic-graph package is used to connect computation nodes, "entities" together using a graph system, akin to what Simulink does. Entities are connected through input and output signals. With the building blocks this package provides, you can easily create a full computation graph for a given problem. It is the basis for the stack of tasks operation.</p>
<h2><a class="anchor" id="controlgraph"></a>
Exemple: Real-time control</h2>
<p>To give a more concrete example, the real-time control used by the Gepetto group for the humanoid robot HRP-2 is detailled.</p>
<p>Real-time control system are usually driven by a cyclic computational node which needs to send a control reference value to each motors of a robot. To compute this control reference values, sensor values need to be provided. In the Stack-Of-Tasks special entities called Device are used to provide an abstract interface to the hardware.</p>
<p>A scheme of the real-time control graph used for the humanoid robot HRP-2 is depicted in the following figure:</p>
<div class="image">
<img src="Concept-Software-Fig.png" alt="Concept-Software-Fig.png"/>
</div>
<p>The device therefore has a specific input which should contain the control vector. This control vector is the result of a computation solving a control problem. The entity in charge of solving this control problem is called "Solver" in the previous figure. In the SoT framework it is often cast as an optimization problem. This optimization problem is build using a control "Task" (not to be confused with the general word task). A control "Task" regulates the difference with a "Feature" computed on the current robot state and a "Desired Feature". For instance when walking, the regulated feature is the robot's Center-Of-Mass (CoM) position. The "Feature" is computed using a library using the robot model and the sensor value. The entity making this computation is "Dyn". A walking pattern generator using foot-steps position given in advance generates the desired value for the CoM. Note that the "Dyn" entity uses the sensor provided by the entity "Robot". </p>
<p>From a pure computer science viewpoint we wish to avoid recomputing data such as articular Jacobians when this is unnecessary. Therefore the data generated by an entity through signals may have two types of dependencies: one dependency related to time and dependencies on other signals. Internally an entity does not recompute the data if no new information is available, it is simply providing the same information computed before. Please note that this package provides only the computational framework to realize the data dependency and the entities. Solvers, libraries to compute mechanical quantities are provided in different packages. </p>
<p>Finally in order to dynamically create a graph, it is possible <b>on-line</b> to load classes of entities and create instances of entities.</p>
<h2><a class="anchor" id="Functionnalities"></a>
Functionnalities</h2>
<ul>
<li>Built-in scripting language* for fast prototyping and testing of computational graph </li>
<li>Support for extensions and modules using dynamic link libraries </li>
<li>Template-based signal definition, independent </li>
<li>Type-safe connection of input and output signals </li>
<li>On-demand signal computation as well as a caching system for signal values allow fast computation of signal values, which is a critical point for real-time systems<br />
See <a class="el" href="index.html#scriptingabout">Building the graph</a></li>
</ul>
<h1><a class="anchor" id="entity"></a>
Computational Entity</h1>
<div class="image">
<img src="entity.png" alt="entity.png"/>
</div>
<h2><a class="anchor" id="entity_definition"></a>
General definition</h2>
<p>Despite the fact that it looks very similar to a ROS node or a CORBA/OpenRTM server, an entity is simply a C++ object. The main idea is that this entity is providing mostly a data-driven functionnality working at very high rate ( <img class="formulaInl" alt="$ 200 Hz$" src="form_0.png"/> or <img class="formulaInl" alt="$ 1 kHz $" src="form_1.png"/>) and should have a minimal computational time foot-print.</p>
<p>For this signals (or ports to use a more classical terminology) are providing a time dependency between data. To implement this, an output signal is linked with a method of the entity. The method calls input signals or use other means to get the needed data. It might be provided by the connection with remote computers through a middleware, or specific protocols, but in general the external data is based upon the sensor values provided by a "Device" entity. For this reason the signal evaluations are realized through the cascade of dependencies and start from the evaluation of an input signal of a periodic node (in general the device). This is realized inside a <b>real-time</b> thread.</p>
<p>To add flexibility to a node, it is possible to add command with arguments to modify the internal behavior of the entity or get information from the entity. As a command is in general asynchronous and rare with respect to the data-flow scheme for the signals the command is in general executed in a <b>none-real-time</b> thread.</p>
<h2><a class="anchor" id="entity_classes"></a>
Entity class</h2>
<p>Entities are implemented as C++ classes and compiled as dynamic libraries. They can be loaded and instancied dynamically. It is therefore necessary to specify the location of their dynamical libraries. However given the time it might take to load the library, it is not advised to do that during a control-law computation. Entity instanciation also implies memory allocation which is also time consuming and thus not advised inside a real-time thread.</p>
<p>The entities will be placed in ${PREFIX}/lib/plugin (since this may change, it is advised to check the install log or the CMakeLists.txt file to check the installation path).</p>
<h2><a class="anchor" id="entities"></a>
List of entities in this package</h2>
<p>Since most of the functionality in projects using the dynamic-graph framework is exposed from entities, here is a short description of all the entities contained in this package. Note that most entities are contained in a binary file that closely matches the entities' names in the scripts; loading this file with the plugin loader will enable creation of this entity through the factory. </p><ul>
<li><a class="el" href="a00005.html">Tracer</a> </li>
<li><a class="el" href="a00004.html">TracerRealTime</a> </li>
<li>ShellProcedure </li>
<li><a class="el" href="a00002.html">ShellFunctions</a></li>
</ul>
<h2><a class="anchor" id="specific_semantics"></a>
Specific semantics with entities</h2>
<p>It is possible to derive classes and apply specific semantic for the entities. In our case we are interested in specific control semantics: </p><ul>
<li>Tasks (more information <a href="http://stack-of-tasks.github.io/sot-core/doxygen/HEAD/a00089.html">here</a>) </li>
<li>Features (more information <a href="http://stack-of-tasks.github.io/sot-core/doxygen/HEAD/a00030.html">here</a>) </li>
<li>Solver (more information <a href="http://stack-of-tasks.github.io/sot-core/doxygen/HEAD/a00078.html">here</a>)</li>
</ul>
<h1><a class="anchor" id="sigintro"></a>
Signals</h1>
<p>Entities can output different types of signals. All signals are templated by a Time tick type parameter (which is used in the caching of signals) - usually <code>int</code>. Signals are also templated after the type of data they accept or provide. For example: (example) For a more detailed programmer-oriented description of signals, please see <a class="el" href="a00105.html">Signals</a></p>
<h1><a class="anchor" id="graph"></a>
Graph</h1>
<p>In this package, the graph considered are directed graphs.</p>
<h2><a class="anchor" id="factory"></a>
Factory</h2>
<p>The class <a class="el" href="a00027.html">dynamicgraph::FactoryStorage</a> is a singleton which register the entity classes and which is allowing the instancation of such classes.</p>
<h2><a class="anchor" id="pool"></a>
Pool</h2>
<p>The class <a class="el" href="a00031.html">dynamicgraph::PoolStorage</a> keeps track of the entities instanciated with the factory. The entities are the graph nodes. Signals are constructed during the class instanciation, they do not live independently from the entities. Signals are the directed edges of the graph. The pool can write a file representing the graph of entities.</p>
<h2><a class="anchor" id="scriptingabout"></a>
Building the graph</h2>
<p>This package provides a scripting language allows entities to define their own commands, and provides a basic framework to build dynamically the computational graph. However bindings have been created with python in the <a href="https://github.com/stack-of-tasks/dynamic-graph-python">dynamic-graph-python package</a> and we strongly recommend to use this package instead of the in-house scripting language.</p>
<h1><a class="anchor" id="usecase"></a>
How to use this package</h1>
<h2><a class="anchor" id="use_programmtically"></a>
Programmatically</h2>
<p>Objects, which are derived from Entities (base class <a class="el" href="a00020.html" title="This class represents an entity, i.e. ">dynamicgraph::Entity</a>), can be declared within the code and compiled to shared libraries (.so/.dll files). These libraries can be loaded at run-time using the PluginLoader methods, and at the same time register their class names to the Factory (see the examples in the SOT documentation to learn how).</p>
<p>The Factory can then create instances of these objects and subsequently register them in the Pool, where they can be listed, accessed, and acted upon (see PoolStorage documentation). Basic commands defined by entities include signal connection graph file generation, help and name print, and signals.</p>
<p>Finally, a shell (command-line) interface is made available thanks to the Interpreter class (see the file test_shell.cpp for an example). Objects deriving from Entity can expose their own commands by overriding the Entity's default commandLine() method. It is possible to load a plugin to register custom shell commands; see shell-functions and shell-procedure for an example.</p>
<p>Some basic shell functions, and support for procedures, are also included. For a complete list of those, load the plugin shell-functions.so and type 'help' at the command line.</p>
<p>The singletons made available by including the corresponding headers in this module are: </p><ul>
<li><a class="el" href="a00027.html" title="Provides a way to create Entity objects from their class name. ">dynamicgraph::FactoryStorage</a> </li>
<li><a class="el" href="a00031.html" title="Singleton that keeps track of all the entities. ">dynamicgraph::PoolStorage</a></li>
</ul>
<p>For an example of a program creating entities in C++, see the unit test test_pool.cpp (in your package source directory/unitTesting).</p>
<h2><a class="anchor" id="use_scripts"></a>
Through scripts</h2>
<p>The program <a class="el" href="a00002.html">dg-shell executable</a> can be used to have scripting access to the dynamic-graph library, where you can execute scripts and commands, load plugins, create entities and connect signals.</p>
<p>Here is a typical use case for programmers: </p><div class="image">
<img src="use-case.png" alt="use-case.png"/>
</div>
<h2><a class="anchor" id="Tutorial"></a>
Tutorial</h2>
<p>A tutorial is available <a href="http://stack-of-tasks.github.io/dynamic-graph-tutorial/">here</a> </p>
<h1><a class="anchor" id="references"></a>
References</h1>
<p><a class="anchor" id="Mansard2009"></a> <b> "A versatile Generalized Inverted Kinematics implementation for collaborative working humanoid robots: The Stack Of Tasks"</b>, <em>N. Mansard, O. Stasse, P. Evrard, A. Kheddar,</em> Int. Conf. on Autonomous Robots, ICAR, 2009</p>
<p><a class="anchor" id="Mansard2007"></a> <b>"Task sequencing for sensor-based control"</b>, <em>N. Mansard, F. Chaumette,</em> IEEE Trans. on Robotics, 23(1):60-72, February 2007 </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Jan 16 2018 12:19:09 for dynamic-graph by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
