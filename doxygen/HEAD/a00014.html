<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>dynamic-graph: dynamicgraph::FactoryStorage Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="a00073.html">dynamicgraph</a>::<a class="el" href="a00014.html">FactoryStorage</a>
  </div>
</div>
<div class="contents">
<h1>dynamicgraph::FactoryStorage Class Reference<br/>
<small>
[<a class="el" href="a00077.html">Core classes and objects</a>]</small>
</h1><!-- doxytag: class="dynamicgraph::FactoryStorage" -->
<p>Provides a way to create <a class="el" href="a00008.html" title="This class represents an entity, i.e.">Entity</a> objects from their class name.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;dynamic-graph/factory.h&gt;</code></p>
<div class="dynheader">
Collaboration diagram for dynamicgraph::FactoryStorage:</div>
<div class="dynsection">
<div class="center"><img src="a00195.png" border="0" usemap="#dynamicgraph_1_1_factory_storage_coll__map" alt="Collaboration graph"/></div>
<map name="dynamicgraph_1_1_factory_storage_coll__map" id="dynamicgraph_1_1_factory_storage_coll__map">
<area shape="rect" title="STL class." alt="" coords="120,87,205,113"/><area shape="rect" title="STL class." alt="" coords="71,7,255,33"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="a00196.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00008.html">Entity</a> *(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#a7374a2cebe8c7c0e24efaa873e6cd662">EntityConstructor_ptr</a> )(const std::string &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function pointer providing an entity instance from its name.  <a href="#a7374a2cebe8c7c0e24efaa873e6cd662"></a><br/></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#ad0338eab2dbd36d03de70445237f9509">FactoryStorage</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor the factory.  <a href="#ad0338eab2dbd36d03de70445237f9509"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#a6b54dcf99ac89fe2861f2b66f89bcd83">~FactoryStorage</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#a20483c6c27a7962077fbabd721f51a10">registerEntity</a> (const std::string &amp;entname, <a class="el" href="a00014.html#a7374a2cebe8c7c0e24efaa873e6cd662">EntityConstructor_ptr</a> ent)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a new entity to the factory.  <a href="#a20483c6c27a7962077fbabd721f51a10"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#a1d9fddc1c9330cae4564e15e5da17e10">deregisterEntity</a> (const std::string &amp;entname)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete an entity from the factory.  <a href="#a1d9fddc1c9330cae4564e15e5da17e10"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00008.html">Entity</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#a1b2f13ecd234ed50083c16f3ed4feac2">newEntity</a> (const std::string &amp;classname, const std::string &amp;objname) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Instantiate (and allocate) an entity.  <a href="#a1b2f13ecd234ed50083c16f3ed4feac2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#a0c63e70310e0ad4ea666aec797bf78a9">existEntity</a> (const std::string &amp;name) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if an <a class="el" href="a00008.html" title="This class represents an entity, i.e.">Entity</a> associated with a particular name has already been registered.  <a href="#a0c63e70310e0ad4ea666aec797bf78a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#a82015768e31062fc3b2ce333a485563f">listEntities</a> (std::vector&lt; std::string &gt; &amp;list) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">List the available entities.  <a href="#a82015768e31062fc3b2ce333a485563f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#a7f1921a85304ff14c5f77a55b7b8be46">commandLine</a> (const std::string &amp;cmdLine, std::istringstream &amp;cmdArgs, std::ostream &amp;os)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Define <a class="el" href="a00014.html" title="Provides a way to create Entity objects from their class name.">FactoryStorage</a> commands.  <a href="#a7f1921a85304ff14c5f77a55b7b8be46"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Provides a way to create <a class="el" href="a00008.html" title="This class represents an entity, i.e.">Entity</a> objects from their class name. </p>
<p>The dynamic graph frameworks relies on entities (see <a class="el" href="a00008.html" title="This class represents an entity, i.e.">Entity</a>) which defines atomic processing units. This class provides a robust way to enumerate and instantiate these entities. Each entity has a name (its type name) and can be instantiated. Each instance also has a name.</p>
<p>For instance one can define a C++ class called MyEntity which inherits from <a class="el" href="a00008.html" title="This class represents an entity, i.e.">dynamicgraph::Entity</a>. This type can be registered into the factory to teach the framework that:</p>
<ul>
<li>this entity exists</li>
<li>this entity can be instantiated (and how to instantiate it).</li>
</ul>
<p>To achieve this, one must pass an entity name and a function pointer.</p>
<p>The entity name will identify the class <b>at run-time</b> (be careful: this may not be equivalent to the C++ class name even if it is recommended to do so).</p>
<p>The function pointer must point on a function taking a string as input and returning an instance of the <a class="el" href="a00008.html" title="This class represents an entity, i.e.">Entity</a> (the concrete subclass, not directly the upper <a class="el" href="a00008.html" title="This class represents an entity, i.e.">Entity</a> class).</p>
<p>The instances returned by this function <b>must</b> be dynamically allocated and the caller <b>must</b> get the ownership of the instance (i.e. it will free it when required).</p>
<p>To finish, please note that the instance name indicates to the entity how the instance itself is called at run-time. This name does not need to be unique and no check is done on it. It is the caller responsibility to make sure that the instance name is appropriate and to check for uniqueness if required.</p>
<p>This class should <b>never</b> be used directly. Use the g_factory global variable instead. The rationale is that each unique name must identify a unique <a class="el" href="a00008.html" title="This class represents an entity, i.e.">Entity</a>. The use of a single instance of this class enforces this behavior, instantiating one yourself would break this property. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a7374a2cebe8c7c0e24efaa873e6cd662"></a><!-- doxytag: member="dynamicgraph::FactoryStorage::EntityConstructor_ptr" ref="a7374a2cebe8c7c0e24efaa873e6cd662" args=")(const std::string &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00008.html">Entity</a>*(* <a class="el" href="a00014.html#a7374a2cebe8c7c0e24efaa873e6cd662">dynamicgraph::FactoryStorage::EntityConstructor_ptr</a>)(const std::string &amp;)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function pointer providing an entity instance from its name. </p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ad0338eab2dbd36d03de70445237f9509"></a><!-- doxytag: member="dynamicgraph::FactoryStorage::FactoryStorage" ref="ad0338eab2dbd36d03de70445237f9509" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dynamicgraph::FactoryStorage::FactoryStorage </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor the factory. </p>
<p>After the initialization, no entities will be available. registerEntity has to be used to add new entities to the object. </p>

</div>
</div>
<a class="anchor" id="a6b54dcf99ac89fe2861f2b66f89bcd83"></a><!-- doxytag: member="dynamicgraph::FactoryStorage::~FactoryStorage" ref="a6b54dcf99ac89fe2861f2b66f89bcd83" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dynamicgraph::FactoryStorage::~FactoryStorage </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a7f1921a85304ff14c5f77a55b7b8be46"></a><!-- doxytag: member="dynamicgraph::FactoryStorage::commandLine" ref="a7f1921a85304ff14c5f77a55b7b8be46" args="(const std::string &amp;cmdLine, std::istringstream &amp;cmdArgs, std::ostream &amp;os)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dynamicgraph::FactoryStorage::commandLine </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>cmdLine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::istringstream &amp;&nbsp;</td>
          <td class="paramname"> <em>cmdArgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define <a class="el" href="a00014.html" title="Provides a way to create Entity objects from their class name.">FactoryStorage</a> commands. </p>
<p>Define two equivalent commands:</p>
<ul>
<li>list</li>
<li>listEntities listing the available entities. </li>
</ul>

</div>
</div>
<a class="anchor" id="a1d9fddc1c9330cae4564e15e5da17e10"></a><!-- doxytag: member="dynamicgraph::FactoryStorage::deregisterEntity" ref="a1d9fddc1c9330cae4564e15e5da17e10" args="(const std::string &amp;entname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dynamicgraph::FactoryStorage::deregisterEntity </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>entname</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delete an entity from the factory. </p>
<p>If the provided entity name does not exist in the factory, an <a class="el" href="a00011.html" title="Generic error class.">ExceptionFactory</a> exception will be raised with the code OBJECT_CONFLICT.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>entname</em>&nbsp;</td><td>the entity name (as passed to registerEntity before) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0c63e70310e0ad4ea666aec797bf78a9"></a><!-- doxytag: member="dynamicgraph::FactoryStorage::existEntity" ref="a0c63e70310e0ad4ea666aec797bf78a9" args="(const std::string &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dynamicgraph::FactoryStorage::existEntity </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if an <a class="el" href="a00008.html" title="This class represents an entity, i.e.">Entity</a> associated with a particular name has already been registered. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>entity name </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Do the entity exist? </dd></dl>

</div>
</div>
<a class="anchor" id="a82015768e31062fc3b2ce333a485563f"></a><!-- doxytag: member="dynamicgraph::FactoryStorage::listEntities" ref="a82015768e31062fc3b2ce333a485563f" args="(std::vector&lt; std::string &gt; &amp;list) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dynamicgraph::FactoryStorage::listEntities </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>list</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>List the available entities. </p>
<p>Available entities are appended to the method argument.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>list</em>&nbsp;</td><td>Available entities will be appended to list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1b2f13ecd234ed50083c16f3ed4feac2"></a><!-- doxytag: member="dynamicgraph::FactoryStorage::newEntity" ref="a1b2f13ecd234ed50083c16f3ed4feac2" args="(const std::string &amp;classname, const std::string &amp;objname) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00008.html">Entity</a>* dynamicgraph::FactoryStorage::newEntity </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>classname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>objname</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Instantiate (and allocate) an entity. </p>
<p>An instance called objname of the entity which type is classname will be allocated by this method.</p>
<p>It is <b>the caller</b> responsibility to free the returned object.</p>
<p>If the class name does not exist, an <a class="el" href="a00011.html" title="Generic error class.">ExceptionFactory</a> exception will be raised with the code UNREFERED_OBJECT.</p>
<p>The instance name (objname) is passed to the <a class="el" href="a00008.html" title="This class represents an entity, i.e.">Entity</a> constructor and it is the caller responsibility to avoid instance name conflicts if necessary.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>classname</em>&nbsp;</td><td>the name of the <a class="el" href="a00008.html" title="This class represents an entity, i.e.">Entity</a> type </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>objname</em>&nbsp;</td><td>the instance name </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Dynamically allocated instance of classname. </dd></dl>

</div>
</div>
<a class="anchor" id="a20483c6c27a7962077fbabd721f51a10"></a><!-- doxytag: member="dynamicgraph::FactoryStorage::registerEntity" ref="a20483c6c27a7962077fbabd721f51a10" args="(const std::string &amp;entname, EntityConstructor_ptr ent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dynamicgraph::FactoryStorage::registerEntity </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>entname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00014.html#a7374a2cebe8c7c0e24efaa873e6cd662">EntityConstructor_ptr</a>&nbsp;</td>
          <td class="paramname"> <em>ent</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a new entity to the factory. </p>
<p>It is not allowed to have several entities using the same name. If this is the case, an <a class="el" href="a00011.html" title="Generic error class.">ExceptionFactory</a> exception will be raised with the code OBJECT_CONFLICT.</p>
<p>If the function pointer is null, an <a class="el" href="a00011.html" title="Generic error class.">ExceptionFactory</a> exception will be raised with the code OBJECT_CONFLICT.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>entname</em>&nbsp;</td><td>the name used to subscribe the entity. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ent</em>&nbsp;</td><td>pointer to a function allocating an entity from an instance name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
</body>
</html>
